Address calculation
===================
Generation
----------
This documents talks about address in memory, storage etc., not the address type
in solidity. An address can be a `sol.pointer`, `sol.array`, `sol.struct` or a
`sol.mapping`. It is generated by any of the following:

- `sol.func` argument (or generally speaking, a block argument)
- `sol.alloca` result
- `sol.malloc` result
- `sol.addr_of` result
- `sol.map` result
- `sol.gep` result

Calculation
-----------
An address calculation op should only yield an address. It can be represented
with an operation of 2 arguments: (base-address, index) in the case of an array
or a struct (where index is the member-index). (mapping-var, key) in the case of
mapping. Note that we don't access the underlying element, but only its address
(even with the mapping, i.e. we only get the address of the value corresponding
to the key).

Side effects
------------
Ideally, address calculation ops should not cause any side effect.

Side effect:

- A key -> value mapping is done using `sol.keccak256` in EraVM and EVM which
  writes the arguments in memory at offset 0. Can we ignore this side effect (in
  the context of optimization/analysis) if offset 0 is only reserved for
  keccak256?

- Out-of-bounds array access is expected to cause panic. Unlike load/store ops,
  address calculation ops know the bounds of the array, so they are expected to
  generate this check. So we can't rely on the side-effect attribute of
  load/store ops.

- Indexing of multi-dimensional memory arrays involve mload'ing to get the
  address of the inner allocation.

No side effect:

- Indexing struct
- Indexing static arrays with constant

What's the best way to represent this? What side effects can be considered
specific to a target and how do we represent that?
